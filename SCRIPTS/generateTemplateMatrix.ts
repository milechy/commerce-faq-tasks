// SCRIPTS/generateTemplateMatrix.ts
// Phase14: Generate intent x persona template coverage matrix as Markdown,
// and also generate gaps (missing persona coverage) report.
//
// Usage (example):
//   npx ts-node SCRIPTS/generateTemplateMatrix.ts
//
// å‰æ:
// - NOTION_API_KEY
// - NOTION_DB_TUNING_TEMPLATES_ID
// ãŒ .env ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã“ã¨ã€‚

import "dotenv/config";
import fs from "node:fs";
import path from "node:path";
import type { NotionTuningTemplate } from "../src/integrations/notion/notionSchemas";
import { NotionSyncService } from "../src/integrations/notion/notionSyncService";

/**
 * Phase14: å…¬å¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ personaTag ä¸€è¦§
 * - ç¾çŠ¶ã®ãƒ†ãƒ³ãƒ—ãƒ¬ + å°†æ¥æ‹¡å¼µã‚’è¦‹æ®ãˆãŸã‚¿ã‚°ç¾¤
 */
const TARGET_PERSONA_TAGS: string[] = [
  "beginner",
  "business",
  "busy",
  "existing_user",
  "intermediate",
  "price_sensitive",
  "general",
];

/**
 * 1ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ x 1ãƒšãƒ«ã‚½ãƒŠã”ã¨ã« 1 è¡Œã«å±•é–‹ã—ãŸæ§‹é€ 
 * ï¼ˆpersona ãŒç©ºã®å ´åˆã¯ '(none)' ã‚’ 1 è¡Œã¨ã—ã¦æ‰±ã†ï¼‰
 */
type FlattenedTemplateRow = {
  phase: string;
  intent: string;
  personaTag: string;
  active: boolean;
  notionPageId: string;
  name: string;
};

/**
 * (phase, intent) ã”ã¨ã®ã‚®ãƒ£ãƒƒãƒ—æƒ…å ±
 */
type GapRow = {
  phase: string;
  intent: string;
  existingPersonaTags: string[];
  missingPersonaTags: string[];
};

/**
 * Notion ã‹ã‚‰ TuningTemplates ã‚’å–å¾—ã—ã€ãƒ•ãƒ©ãƒƒãƒˆãªè¡Œé…åˆ—ã«å¤‰æ›ã™ã‚‹
 */
async function fetchAndFlattenTemplates(): Promise<FlattenedTemplateRow[]> {
  const notionDbId = process.env.NOTION_DB_TUNING_TEMPLATES_ID;

  if (!notionDbId) {
    throw new Error("NOTION_DB_TUNING_TEMPLATES_ID is not set in environment");
  }

  const syncService = new NotionSyncService();
  const templates: NotionTuningTemplate[] =
    await syncService.syncTuningTemplates(notionDbId);

  const rows: FlattenedTemplateRow[] = [];

  for (const tpl of templates) {
    const phase = tpl.phase || "";
    const intent = tpl.intent ?? "";
    const personaList =
      tpl.persona && tpl.persona.length > 0 ? tpl.persona : ["(none)"];

    for (const personaTag of personaList) {
      rows.push({
        phase,
        intent,
        personaTag,
        active: tpl.active,
        notionPageId: tpl.notionPageId,
        name: tpl.name,
      });
    }
  }

  // phase, intent, personaTag ã®é †ã§ã‚½ãƒ¼ãƒˆ
  rows.sort((a, b) => {
    if (a.phase !== b.phase) return a.phase.localeCompare(b.phase);
    if (a.intent !== b.intent) return a.intent.localeCompare(b.intent);
    return a.personaTag.localeCompare(b.personaTag);
  });

  return rows;
}

/**
 * Markdown ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆãƒ•ãƒ«ãƒãƒˆãƒªã‚¯ã‚¹ï¼‰ã‚’ç”Ÿæˆã™ã‚‹
 */
function buildMatrixMarkdown(rows: FlattenedTemplateRow[]): string {
  const lines: string[] = [];

  lines.push("# Tuning Template Matrix");
  lines.push("");
  lines.push(
    "> This file is auto-generated by `SCRIPTS/generateTemplateMatrix.ts`."
  );
  lines.push("> Do not edit this file manually.");
  lines.push("");
  lines.push("| Phase | Intent | PersonaTag | Active | TemplateId | Name |");
  lines.push("|-------|--------|------------|--------|------------|------|");

  for (const row of rows) {
    const phase = row.phase || "-";
    const intent = row.intent || "-";
    const personaTag = row.personaTag || "(none)";
    const active = row.active ? "YES" : "NO";
    const templateId = row.notionPageId;
    const name = row.name.replace(/\|/g, "\\|");

    lines.push(
      `| ${phase} | ${intent} | ${personaTag} | ${active} | ${templateId} | ${name} |`
    );
  }

  lines.push("");
  return lines.join("\n");
}

/**
 * (phase, intent) ã”ã¨ã®ä¸è¶³ personaTag ã‚’é›†è¨ˆã™ã‚‹
 */
function computeGaps(rows: FlattenedTemplateRow[]): GapRow[] {
  // (phase,intent) -> Set(personaTag)
  const map = new Map<
    string,
    { phase: string; intent: string; personas: Set<string> }
  >();

  for (const row of rows) {
    const key = `${row.phase}::${row.intent}`;
    if (!map.has(key)) {
      map.set(key, {
        phase: row.phase,
        intent: row.intent,
        personas: new Set<string>(),
      });
    }

    // '(none)' ã¯ã€Œãƒšãƒ«ã‚½ãƒŠæœªè¨­å®šã€æ‰±ã„ãªã®ã§ã‚®ãƒ£ãƒƒãƒ—åˆ¤å®šã«ã¯å«ã‚ãªã„
    if (row.personaTag && row.personaTag !== "(none)") {
      map.get(key)!.personas.add(row.personaTag);
    }
  }

  const gapRows: GapRow[] = [];

  for (const { phase, intent, personas } of map.values()) {
    // Clarify ãªã© intent æœªè¨­å®šã®ã‚‚ã®ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ãŸã‘ã‚Œã°ã“ã“ã§æ¡ä»¶ã‚’å…¥ã‚Œã¦ã‚‚ã‚ˆã„
    const existing = Array.from(personas).sort();
    const missing = TARGET_PERSONA_TAGS.filter((tag) => !personas.has(tag));

    if (missing.length === 0) continue;

    gapRows.push({
      phase,
      intent,
      existingPersonaTags: existing,
      missingPersonaTags: missing,
    });
  }

  // ä¸¦ã³ã‚’å›ºå®š
  gapRows.sort((a, b) => {
    if (a.phase !== b.phase) return a.phase.localeCompare(b.phase);
    return a.intent.localeCompare(b.intent);
  });

  return gapRows;
}

/**
 * ä¸è¶³ãƒ†ãƒ³ãƒ—ãƒ¬ä¸€è¦§ã® Markdown ã‚’ç”Ÿæˆã™ã‚‹
 */
function buildGapsMarkdown(gaps: GapRow[]): string {
  const lines: string[] = [];

  lines.push("# Tuning Template Gaps");
  lines.push("");
  lines.push("> Auto-generated by `SCRIPTS/generateTemplateMatrix.ts`.");
  lines.push("> Shows missing personaTag coverage for each (Phase, Intent).");
  lines.push("> Do not edit this file manually.");
  lines.push("");

  if (gaps.length === 0) {
    lines.push(
      "All target personaTags are covered for all (Phase, Intent). ğŸ‰"
    );
    lines.push("");
    return lines.join("\n");
  }

  lines.push("| Phase | Intent | ExistingPersonaTags | MissingPersonaTags |");
  lines.push("|-------|--------|---------------------|--------------------|");

  for (const gap of gaps) {
    const existing =
      gap.existingPersonaTags.length > 0
        ? `[${gap.existingPersonaTags.map((t) => `"${t}"`).join(", ")}]`
        : "[]";
    const missing =
      gap.missingPersonaTags.length > 0
        ? `[${gap.missingPersonaTags.map((t) => `"${t}"`).join(", ")}]`
        : "[]";

    lines.push(
      `| ${gap.phase || "-"} | ${
        gap.intent || "-"
      } | ${existing} | ${missing} |`
    );
  }

  lines.push("");
  return lines.join("\n");
}

async function main() {
  try {
    const rows = await fetchAndFlattenTemplates();

    // 1) ãƒ•ãƒ«ãƒãƒˆãƒªã‚¯ã‚¹å‡ºåŠ›
    const matrixMarkdown = buildMatrixMarkdown(rows);
    const matrixOutPath = path.join(
      __dirname,
      "..",
      "docs",
      "TEMPLATE_MATRIX.md"
    );
    fs.writeFileSync(matrixOutPath, matrixMarkdown, "utf8");

    // 2) ã‚®ãƒ£ãƒƒãƒ—ä¸€è¦§å‡ºåŠ›
    const gaps = computeGaps(rows);
    const gapsMarkdown = buildGapsMarkdown(gaps);
    const gapsOutPath = path.join(__dirname, "..", "docs", "TEMPLATE_GAPS.md");
    fs.writeFileSync(gapsOutPath, gapsMarkdown, "utf8");

    // eslint-disable-next-line no-console
    console.log(
      `[generateTemplateMatrix] wrote ${rows.length} rows to ${matrixOutPath}`
    );
    // eslint-disable-next-line no-console
    console.log(
      `[generateTemplateMatrix] wrote ${gaps.length} gap rows to ${gapsOutPath}`
    );
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error("[generateTemplateMatrix] failed:", error);
    process.exit(1);
  }
}

if (require.main === module) {
  // å®Ÿè¡Œã•ã‚ŒãŸã¨ãã®ã¿ main() ã‚’å‘¼ã³å‡ºã™
  // ï¼ˆä»–ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‹ã‚‰ import ã•ã‚ŒãŸå ´åˆã¯å®Ÿè¡Œã—ãªã„ï¼‰
  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  main();
}
