// src/agent/flow/dialogOrchestrator.ts

import type { DialogMessage, MultiStepQueryPlan } from '../dialog/types'
import { runSearchAgent } from './searchAgent'

export type OrchestratorStep =
  | { type: 'clarify_plan'; questions: string[] }
  | { type: 'search_executed'; query: string; topK: number; source: 'searchAgent' }
  | MultiStepQueryPlan['steps'][number]

export interface OrchestratorInput {
  plan: MultiStepQueryPlan
  sessionId: string
  history: DialogMessage[]
  options?: {
    topK?: number
    debug?: boolean
  }
}

export interface OrchestratorResult {
  answer: string | null
  steps: OrchestratorStep[]
  needsClarification: boolean
  clarifyingQuestions?: string[]
  final: boolean
}

/**
 * Dialog Orchestrator
 *
 * Phase3 v1: lightweight executor for MultiStepQueryPlan.
 * - Clarify: return clarifyingQuestions, no search
 * - Follow-up / Search: call searchAgent once
 * - Answer step is still generated by final synthesis elsewhere
 *
 * Phase14 以降:
 * - SalesFlow（Propose / Recommend / Close）は別レイヤーの SalesOrchestrator で扱う
 * - このモジュールは「検索まわりの実行」に責務を限定する
 */
export async function runDialogOrchestrator(
  input: OrchestratorInput,
): Promise<OrchestratorResult> {
  const { plan, options } = input
  const debug = options?.debug ?? false

  // 1) Clarification branch
  if (plan.needsClarification) {
    return {
      answer: null,
      steps: [
        ...plan.steps,
        {
          type: 'clarify_plan',
          questions: plan.clarifyingQuestions ?? [],
        },
      ],
      needsClarification: true,
      clarifyingQuestions: plan.clarifyingQuestions ?? [],
      final: false,
    }
  }

  // 2) If we have follow-up queries, prefer them
  const followQueries = plan.followupQueries
  const searchQueries = followQueries?.length
    ? followQueries
    : plan.steps
        .filter((s) => s.type === 'search')
        .map((s: any) => s.query)

  if (!searchQueries || searchQueries.length === 0) {
    return {
      answer: null,
      steps: plan.steps,
      needsClarification: false,
      final: true,
    }
  }

  const primaryQuery = searchQueries[0]

  // 3) Execute search (single-turn for Phase3 v1)
  const searchResult = await runSearchAgent({
    q: primaryQuery,
    topK: options?.topK ?? 8,
    debug,
    useLlmPlanner: false,
  })

  // 4) Return orchestrated result
  return {
    answer: searchResult.answer,
    steps: [
      ...plan.steps,
      {
        type: 'search_executed',
        query: primaryQuery,
        topK: options?.topK ?? 8,
        source: 'searchAgent',
      },
    ],
    needsClarification: false,
    final: true,
  }
}